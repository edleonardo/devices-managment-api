# Devices REST API

A production-ready REST API for managing device resources, built with NestJS, TypeScript, PostgreSQL, and Redis.

## Features

âœ¨ **Core Functionality**

- Full CRUD operations for device resources
- Query filtering by brand and state
- Domain validations (in-use protection, immutable creation time)

ğŸš€ **Production Ready**

- Request tracing with unique trace IDs
- Automatic logging with file context
- Global error handling with friendly error messages
- Redis caching for all GET operations
- Swagger API documentation
- Comprehensive test coverage (unit + e2e)
- Docker containerization for dev and prod

ğŸ›¡ï¸ **Best Practices**

- TypeScript 5+ with strict mode
- Class-validator for automatic DTO validation
- Clean architecture with separation of concerns
- Repository pattern with TypeORM
- Cache invalidation strategies

## Tech Stack

- **Runtime**: Node.js 20 (Alpine)
- **Framework**: NestJS 10
- **Language**: TypeScript 5+
- **Database**: PostgreSQL 16
- **Cache**: Redis 7
- **ORM**: TypeORM
- **Validation**: class-validator
- **API Docs**: Swagger/OpenAPI
- **Testing**: Jest
- **Containerization**: Docker & Docker Compose

## Quick Start

### Prerequisites

- Docker & Docker Compose
- Node.js 20+ (for local development)

### Installation & Running

1. **Clone the repository**

```bash
git clone
cd devices-api
```


2. **Create environment file**

```bash
cp .env.example .env
```

3. **Start with Docker Compose (Development)**

```bash
docker compose up --build
```

The API will be available at:

- API: http://localhost:3000
- API Documentation: http://localhost:3000/api/docs

4. **Run tests**

```bash
# Inside the container
docker compose exec api npm run test

# With coverage
docker compose exec api npm run test:cov

# E2E tests
docker compose exec api npm run test:e2e
```

### Production Deployment

```bash
docker compose -f docker-compose.prod.yml up --build -d
```

## API Endpoints

### Devices

| Method | Endpoint                 | Description             | Cache                      |
| ------ | ------------------------ | ----------------------- | -------------------------- |
| POST   | `/devices`               | Create a new device     | Invalidates all GET caches |
| GET    | `/devices`               | Get all devices         | âœ… Cached                  |
| GET    | `/devices?brand={brand}` | Filter by brand         | âœ… Cached                  |
| GET    | `/devices?state={state}` | Filter by state         | âœ… Cached                  |
| GET    | `/devices/:id`           | Get single device       | âœ… Cached                  |
| PATCH  | `/devices/:id`           | Update device (partial) | Invalidates related caches |
| PUT    | `/devices/:id`           | Update device           | Invalidates related caches |
| DELETE | `/devices/:id`           | Delete device           | Invalidates related caches |

### Device States

- `available` - Device is available for use
- `in-use` - Device is currently being used
- `inactive` - Device is inactive

### Example Requests

**Create Device**

````bash
curl -X POST http://localhost:3000/devices \
  -H "Content-Type: application/json" \
  -d '{
    "name": "iPhone 15 Pro",
    "brand": "Apple",
    "state": "available"
  }'
````

**Get All Devices**

````bash
curl http://localhost:3000/devices
````

**Filter by Brand**

```bash
curl http://localhost:3000/devices?brand=Apple
```

**Update Device**

```bash
curl -X PATCH http://localhost:3000/devices/{id} \
  -H "Content-Type: application/json" \
  -d '{"state": "in-use"}'
```

## Domain Validations

The API enforces the following business rules:

1. **ID is auto-generated** - UUID generated by the database, cannot be provided in requests
2. **Creation time is auto-generated** - Timestamp set by database, cannot be provided or updated
3. **Name/brand locked when in-use** - Cannot update `name` or `brand` when device state is `in-use`
4. **In-use devices cannot be deleted** - Must change state before deletion

Violations return clear error messages with HTTP 400 status.

## Caching Strategy

### Cached Operations

- `GET /devices` - All devices list
- `GET /devices?brand={brand}` - Devices by brand
- `GET /devices?state={state}` - Devices by state
- `GET /devices/:id` - Single device

### Cache Invalidation

Operations that modify data automatically invalidate relevant cache keys:

- **CREATE** â†’ Invalidates: all devices list, brand/state caches
- **UPDATE** â†’ Invalidates: specific device, all devices list, related brand/state caches
- **DELETE** â†’ Invalidates: specific device, all devices list, related brand/state caches

Default TTL: 5 minutes (configurable via `CACHE_TTL` env var)

## Logging & Tracing

Every request includes:

1. **Trace ID** - Unique identifier (`X-Trace-Id` header) for request tracking
2. **Automatic logging** - All requests/responses logged with:
   - Trace ID
   - HTTP method and path
   - Response time
   - File context (controller.method)
3. **Error logging** - Full stack traces with trace IDs for debugging

Example log:

```
[DevicesController.create] [abc-123-def] POST /devices - Request started
[DevicesService] Creating device: iPhone 15 Pro
[DevicesController.create] [abc-123-def] POST /devices - Completed in 45ms
```

## Testing

### Test Coverage Goals

- **Unit tests**: 80%+ coverage
- **E2E tests**: All critical paths

### Running Tests

```bash
# Unit tests
npm test

# Watch mode
npm run test:watch

# Coverage report
npm run test:cov

# E2E tests
npm run test:e2e
```

### Test Structure

```
devices-api/
â”œâ”€â”€ src/
|  â”œâ”€â”€ devices/
|  |  â”œâ”€â”€ __tests__/
|  |  |  â”œâ”€â”€ devices.controller.spec.ts  # Controller unit tests
|  |  |  â”œâ”€â”€ devices.service.spec.ts     # Service unit tests
|â”€â”€ test/ 
â””  â””â”€â”€ devices.e2e.spec.ts        # End-to-end integration tests
```

## Project Structure

```
devices-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ common/              # Shared utilities
â”‚   â”‚   â””â”€â”€ interceptors/    # Trace ID, logging, error handling
â”‚   â”œâ”€â”€ config/             # Configuration modules
â”‚   â”œâ”€â”€ devices/            # Devices domain
â”‚   â”‚   â”œâ”€â”€ dto/           # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ entities/      # TypeORM entities
â”‚   â”‚   â”œâ”€â”€ __tests__/     # Tests
â”‚   â”‚   â”œâ”€â”€ devices.controller.ts
â”‚   â”‚   â”œâ”€â”€ devices.service.ts
â”‚   â”‚   â””â”€â”€ devices.module.ts
â”‚   â”œâ”€â”€ app.module.ts      # Root module
â”‚   â””â”€â”€ main.ts           # Application entry point
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile.dev     # Development image
â”‚   â””â”€â”€ Dockerfile.prod    # Production image
â”œâ”€â”€ test/                  # E2E tests
â””â”€â”€ docker-compose.yml     # Services orchestration
```

## Environment Variables

| Variable      | Description         | Default        |
| ------------- | ------------------- | -------------- |
| `NODE_ENV`    | Environment         | `development`  |
| `PORT`        | API port            | `3000`         |
| `DB_HOST`     | PostgreSQL host     | `localhost`    |
| `DB_PORT`     | PostgreSQL port     | `5432`         |
| `DB_USERNAME` | Database user       | `devices_user` |
| `DB_PASSWORD` | Database password   | `devices_pass` |
| `DB_DATABASE` | Database name       | `devices_db`   |
| `REDIS_HOST`  | Redis host          | `localhost`    |
| `REDIS_PORT`  | Redis port          | `6379`         |
| `CACHE_TTL`   | Cache TTL (seconds) | `300`          |

## Development

### Local Development (without Docker)

1. **Install dependencies**

```bash
npm install
```

2. **Start PostgreSQL and Redis** (use Docker Compose or local instances)

3. **Run in watch mode**

```bash
npm run start:dev
```

### Code Quality

```bash
# Linting
npm run lint

# Format code
npm run format
```

## Future Improvements

- [ ] Implement Redis SCAN for pattern-based cache invalidation
- [ ] Add pagination for list endpoints
- [ ] Implement soft deletes with audit trail
- [ ] Implement bulk operations (create/update/delete multiple)
- [ ] Add search functionality (fuzzy search on name/brand)
- [ ] Husky + lint-staged pre-commit hooks

## Known Limitations

1. **Cache invalidation**: Currently invalidates specific known keys. For production, implement Redis SCAN to invalidate all matching patterns.

2. **Concurrent updates**: Uses last-write-wins. Consider optimistic locking for high-concurrency scenarios.

3. **In-memory session**: No distributed session management. For multi-instance deployments, implement Redis-based sessions.

## Troubleshooting

### Database connection issues

```bash
# Check if PostgreSQL is running
docker compose ps

# View PostgreSQL logs
docker compose logs postgres

# Reset database
docker compose down -v
docker compose up --build
```

### Redis connection issues

```bash
# Check Redis status
docker compose exec redis redis-cli ping

# View Redis logs
docker compose logs redis
```

### Clear all caches

```bash
docker compose exec redis redis-cli FLUSHALL
```

## Author

ğŸ‘¤ **Eduardo Alves**

- Github: [@ed-leonardo](https://github.com/ed-leonardo)
- LinkedIn: [Eduardo Alves Leonardo](https://www.linkedin.com/in/eduardo-alves-leonardo/)
